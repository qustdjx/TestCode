# 排序算法
* 快速排序
```
1.从数列中挑出一个元素，称为 “基准”（pivot），
2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。
  在这个分区 退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
```
![Alt text](./快速排序.gif)


* 归并排序
```
1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2.设定两个指针，最初位置分别为两个已经排序序列的起始位置
3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4.重复步骤3直到某一指针达到序列尾
5.将另一序列剩下的所有元素直接复制到合并序列尾
```
![Alt text](./归并排序.gif)



* 堆排序
```
堆积排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
```
![Alt text](./堆排序.gif)



* 选择排序
```
1.首先在未排序序列中找到最小元素，存放到排序序列的起始位置
2.然后，再从剩余未排序元素中继续寻找最小元素，
3.然后放到排序序列末尾。
以此类推，直到所有元素均排序完毕。
```
![Alt text](./选择排序.gif)



* 冒泡排序
```
1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3.针对所有的元素重复以上的步骤，除了最后一个。
4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
```
![Alt text](./冒泡排序.gif)



* 插入排序
```
1.从第一个元素开始，该元素可以认为已经被排序
2.取出下一个元素，在已经排序的元素序列中从后向前扫描
3.如果该元素（已排序）大于新元素，将该元素移到下一位置
4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5.将新元素插入到该位置中
6.重复步骤2
```
![Alt text](./插入排序.gif)

* 希尔排序
```
希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。
```
![Alt text](./希尔排序.gif)


* 递归算法
```
  递归满足2个条件：
1.有反复执行的过程（调用自身）
2.有跳出反复执行过程的条件（递归出口）
```
*迭代算法
```
迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程,跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题。迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。
```
* 贪心算法
```
1.所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，
  他所做出的仅是在某种意义上的局部最优解。
2.贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优
  解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。
  所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。
```

* 回溯算法
```
回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。用回溯算法解决问题的一般步骤为：

1.定义一个解空间，它包含问题的解。
2.利用适于搜索的方法组织解空间。
3.利用深度优先法搜索解空间。
4.利用限界函数避免移动到不可能产生解的子空间。
问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。
```
